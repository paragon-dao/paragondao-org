<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonic Frequency Authentication: Attested Local Authorization for Personal AI with Confidential Compute</title>
    <style>
        /* Back to site header */
        .site-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #1a1207 0%, #3d2e1a 50%, #2a1f0f 100%);
            padding: 14px 28px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(26,18,7,0.25), 0 1px 4px rgba(212,160,23,0.1);
        }
        .site-header a {
            color: #fff;
            text-decoration: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .site-logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            font-size: 16px;
        }
        .site-logo-icon {
            width: 34px;
            height: 34px;
            border-radius: 8px;
            overflow: hidden;
        }
        .site-logo-text {
            display: flex;
            flex-direction: column;
            line-height: 1;
        }
        .site-logo-name {
            font-size: 16px;
            font-weight: 700;
        }
        .site-logo-tagline {
            font-size: 9px;
            font-weight: 500;
            color: rgba(240,187,51,0.8);
            letter-spacing: 0.02em;
        }
        .back-btn {
            padding: 8px 18px;
            background: rgba(212,160,23,0.15);
            border: 1px solid rgba(212,160,23,0.4);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .back-btn:hover {
            background: rgba(212,160,23,0.25);
            color: #fff;
        }
        
        body { font-family: "Times New Roman", serif; font-size: 13pt; line-height: 1.4; max-width: 8.5in; margin: 0 auto; padding: 0.8in; padding-top: calc(0.8in + 60px); color: #000; background: white; }
        .title { font-size: 28pt; font-weight: bold; text-align: center; margin: 0 0 0.5in 0; line-height: 1.4; letter-spacing: -0.3pt; }
        .version { font-size: 13pt; text-align: center; margin: 0.05in 0; font-style: italic; }
        .author { font-size: 13pt; text-align: center; margin: 0.2in 0 0.1in 0; }
        .organization { font-size: 13pt; text-align: center; margin: 0.05in 0 0.1in 0; font-style: italic; }
        .email, .website { font-size: 13pt; text-align: center; margin: 0.05in 0; }
        h2 { font-size: 16pt; font-weight: bold; margin: 0.35in 0 0.12in 0; line-height: 1.3; }
        h3 { font-size: 13pt; font-weight: bold; margin: 0.25in 0 0.08in 0; line-height: 1.3; }
        p  { margin: 0.08in 0; text-align: justify; }
        ul { margin: 0.08in 0 0.12in 0.18in; }
        .abstract { border: 1px solid #000; padding: 0.15in; margin: 0.2in 0; background: #fafafa; }
        .box { border: 1px solid #000; padding: 0.12in; margin: 0.18in 0; }
        .small { font-size: 10pt; }
        .mono { font-family: "Courier New", monospace; font-size: 11pt; }
        .references { margin: 0.2in 0; }
        .references ol { margin: 0.1in 0; padding-left: 0.3in; }
        .references li { margin: 0.08in 0; text-align: left; }
        .references li p { margin: 0; text-align: left; }

        /* Sentinel Frog */
        .sentinel-frog {
            position: fixed; bottom: 20px; right: 24px; z-index: 999; cursor: pointer;
            filter: drop-shadow(0 4px 12px rgba(20,184,166,0.2));
            transition: bottom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .sentinel-frog:hover { bottom: 32px; }
        .sentinel-frog .frog-body { animation: frogBreathe 3.5s ease-in-out infinite; transform-origin: 28px 36px; }
        .sentinel-frog .frog-belly { animation: bellyBreathe 3.5s ease-in-out infinite; transform-origin: 28px 36px; }
        .sentinel-frog .frog-throat { animation: throatPulse 3.5s ease-in-out infinite; transform-origin: 28px 28px; }
        .sentinel-frog .frog-nostrils { animation: nostrilFlare 3.5s ease-in-out infinite; }
        .sentinel-frog .frog-head { animation: chestLift 3.5s ease-in-out infinite; }
        .sentinel-frog .frog-glow { animation: breathGlow 3.5s ease-in-out infinite; }
        .sentinel-frog .frog-eyes { animation: frogBlink 4s ease-in-out infinite; }
        @keyframes frogBreathe { 0%, 100% { transform: scaleY(1) scaleX(1); } 45% { transform: scaleY(1.12) scaleX(0.95); } }
        @keyframes bellyBreathe { 0%, 100% { transform: scaleY(1) scaleX(1); opacity: 0.45; } 45% { transform: scaleY(1.25) scaleX(1.2); opacity: 0.7; } }
        @keyframes throatPulse { 0%, 100% { transform: scale(1); opacity: 0.3; } 45% { transform: scale(1.4); opacity: 0.65; } }
        @keyframes nostrilFlare { 0%, 100% { transform: scale(1); opacity: 0.3; } 45% { transform: scale(1.5); opacity: 0.6; } }
        @keyframes chestLift { 0%, 100% { transform: translateY(0); } 45% { transform: translateY(-1.5px); } }
        @keyframes breathGlow { 0%, 100% { transform: scale(1); opacity: 0.05; } 45% { transform: scale(1.3); opacity: 0.12; } }
        @keyframes frogBlink { 0%, 90%, 95%, 100% { opacity: 1; } 92% { opacity: 0; } }
        @media print { .sentinel-frog { display: none; } }
    </style>
</head>
<body>
    <header class="site-header">
        <a href="/" class="site-logo">
            <span class="site-logo-icon"><img src="/favicon.svg" alt="ParagonDAO" style="width:34px;height:34px;display:block;"></span>
            <span class="site-logo-text">
                <span class="site-logo-name">ParagonDAO</span>
                <span class="site-logo-tagline">The Health Economy</span>
            </span>
        </a>
        <a href="/whitepaper" class="back-btn">← Back to Whitepapers</a>
    </header>
    
    <div class="title">Harmonic Frequency Authentication:<br>Attested Local Authorization for Personal AI<br>with Confidential Compute</div>
    <div class="version">Whitepaper v1.3</div>
    <div class="author">ParagonDAO Research</div>
    <div class="organization">Harmonic Frequency (HF) Authentication & Confidential VM Architecture</div>
    <div class="website">https://paragondao.org</div>

    <h2>Abstract</h2>
    <div class="abstract">
        <p>
            This paper presents Auth‑HF, an <strong>attested</strong> local authorization architecture for personal AI
            on user devices. Auth‑HF fuses frequency‑native identity (HF presence, liveness, owner binding) with
            <strong>remote attestation‑gated key release</strong> in confidential compute (TDX/SEV‑SNP/SGX) and
            per‑operation capabilities enforced at filesystem/kernel boundaries. We analyze the strongest practical
            adversary—<em>a rogue, rooted system administrator on the same host</em>—and show how Auth‑HF resists
            cross‑admin access by combining: (1) HF‑gated continuous presence, (2) per‑operation, process‑bound
            capabilities over Unix Domain Sockets (no bearer tokens), (3) just‑in‑time (JIT) encryption with hardware‑
            sealed keys, and (4) execution inside a confidential VM with <strong>verifiable attestation</strong>
            gating decryption. We discuss residual risks, operational guidance, and deployment patterns that move from
            “best effort” to <em>measured, attestable protection</em> fit for personal bio‑data and AI models.
        </p>
    </div>

    <h2>1. Introduction</h2>
    <p>
        Personal AI is transitioning from general assistants to <em>creator-bound systems</em> that act as extensions of
        their owners’ cognition. As capabilities increase, so does the sensitivity of the inputs required to personalize
        and align these systems: continuous audio of the household, breathing and heart-rate variability, EEG band
        powers, retinal and gait signatures, genome/DNA summaries, longitudinal medical records, private journals,
        financial ledgers, legal work product, and confidential strategy. The paradox is immediate: the more powerful and
        useful a personal AI becomes, the more intimate the data it must process—and the higher the stakes if any
        component of the local stack is compromised.
    </p>
    <p>
        Consider the high-stakes case: a head of state—the President of the United States, the President of China, or the
        CEO of a systemically important institution—operates a personal AI on-premise. They employ trusted technical
        administrators with full system privileges. Traditional controls (disk encryption, OS permissions, application
        sandboxing) assume administrators are guardians; they do not reliably defend <em>against</em> administrators. We
        adopt the stricter assumption: even an unlikely rogue administrator with kernel access, debugger capability, and
        physical proximity must be unable to read or exfiltrate protected personal AI data while the system is up and
        serving.
    </p>
    <p>
        This paper proposes <strong>Auth‑HF</strong>, a design that treats authorization as a continuous,
        physiology‑bound presence signal (HF) and binds decryption and I/O to attested execution inside a confidential VM.
        Rather than long‑lived credentials or bearer tokens, every file operation requires a per‑operation capability
        cryptographically sealed to the requesting process identity and verified in the same privileged context that
        performs I/O. Plaintext exists only transiently in memory; keys are sealed to attestation reports and released
        only under active owner presence (liveness) and policy. The result is an authorization substrate that remains
        enforceable even when conventional trust in local administrators no longer holds.
    </p>
    <div class="box small">
        <p><strong>Problem.</strong> Local administrators can, by design, read disks, memory, and processes, making
        conventional OS controls insufficient for personal AI privacy at peak capability.</p>
        <p><strong>Goal.</strong> Design a local authorization and storage flow where protected data stays confidential
        and access‑controlled <em>even if</em> a root‑level administrator on the same host attempts to bypass guards.</p>
        <p><strong>Approach.</strong> HF presence (owner binding + liveness) gates per‑operation capabilities; data at
        rest is always encrypted; keys are sealed to a remote‑attested confidential VM; verify and I/O are atomic in the
        enforcement path; audit is tamper‑evident.</p>
    </div>

    <h2>2. Threat Model</h2>
    <h3>2.1 Adversary</h3>
    <ul>
        <li>Local administrator with root/NT AUTHORITY\SYSTEM, kernel module loading, ptrace/debug, and VFS access.</li>
        <li>Able to read raw disks, page cache, and process memory; able to spoof audio/EEG inputs and system time.</li>
        <li>Goal: read or exfiltrate protected files/model states belonging to another admin/user.</li>
    </ul>

    <h3>2.2 Assets</h3>
    <ul>
        <li>Personal AI data (bio signals, embeddings, models, checkpoints).</li>
        <li>Protected files within HF‑gated folders and application data paths.</li>
    </ul>

    <h3>2.3 Non‑Goals</h3>
    <ul>
        <li>Defending against physical attacks on powered‑off devices without disk encryption.</li>
        <li>Bypassing a compromised firmware/BIOS without measured boot/attestation.</li>
    </ul>

    <h2>3. Architectural Overview</h2>
    <div class="box">
        <p><strong>Core pillars:</strong></p>
        <ul>
            <li><strong>Confidential VM + Attestation (First‑Class):</strong> File‑service and key broker run inside TDX/SEV‑SNP (or SGX enclave), with keys released only after <em>successful remote attestation</em> and active HF presence.</li>
            <li><strong>HF Presence & Identity:</strong> Frequency‑native verification (voice/breath/ambient/EEG) emits short‑lived presence/liveness signals.</li>
            <li><strong>Per‑Op Capabilities (No Bearers):</strong> AF_UNIX with peer credentials; capabilities sealed to pid/uid/start_time/path/mode; TTL ≤ 1s.</li>
            <li><strong>JIT Encryption:</strong> AES‑GCM per‑file keys; plaintext only in memory during verified I/O; buffers zeroized on close.</li>
            <li><strong>Kernel Enforcement:</strong> LSM/eBPF or FUSE prototype with atomic verify+I/O to avoid TOCTOU.</li>
        </ul>
    </div>

    <h2>4. Protocol Elements</h2>
    <h3>4.1 HF Verification</h3>
    <ul>
        <li>Enrollment builds local prototypes (owner binding) from 60–120s capture.</li>
        <li>Continuous presence windows (100–300ms) with liveness (breath cadence + prompted hum + ambient continuity).</li>
        <li>Output: <span class="mono">Presence{confidence, liveness, ts, device}</span> to gate key release.</li>
    </ul>

    <h3>4.2 Capability Issuance</h3>
    <ul>
        <li>Client sends intent over AF_UNIX; gateway verifies HF presence and peer pid/uid; generates AEAD‑sealed capability.</li>
        <li>Capability fields: <span class="mono">pid, uid, start_time, cgroup, inode, path, mode, counter, exp&lt;=1s</span>.</li>
        <li>Validated in the same privileged context that performs I/O (TOCTOU‑safe).</li>
    </ul>

    <h3>4.3 Confidential Compute Architecture</h3>
    <p>
        <strong>Confidential Compute</strong> (also called <strong>Trusted Execution Environments</strong>, or <strong>TEEs</strong>)
        provides hardware‑backed isolation that protects code execution and data even from privileged system software
        (OS kernel, hypervisor, firmware) and physical attackers. A <strong>Confidential Virtual Machine (CVM)</strong> is a
        VM or enclave that runs with memory encryption and measured boot, enabling remote attestation of code integrity.
    </p>
    
    <h4>4.3.1 Core Principles</h4>
    <ul>
        <li><strong>Memory Encryption:</strong> All data in the CVM is encrypted in memory by the CPU or memory controller;
            the hypervisor and OS cannot read plaintext even with root access.</li>
        <li><strong>Measured Boot:</strong> Code running in the CVM is cryptographically measured (hashed) at launch,
            producing an immutable measurement of the code, configuration, and initial state.</li>
        <li><strong>Remote Attestation:</strong> External verifiers can cryptographically verify what code is running inside
            the CVM by validating hardware‑signed attestation reports against trusted roots (Intel, AMD).</li>
        <li><strong>Isolation:</strong> Even the OS kernel cannot access CVM memory or modify CVM code without detection.</li>
        <li><strong>Sealed Storage:</strong> Encryption keys can be sealed (encrypted) such that they only decrypt when
            the same measured code runs again, binding keys to code integrity.</li>
    </ul>

    <h4>4.3.2 Hardware TEE Types</h4>
    <p>
        Auth‑HF supports multiple TEE implementations, with automatic detection of available hardware:
    </p>
    <ul>
        <li><strong>Intel TDX (Trust Domain Extensions):</strong> Hardware‑isolated VMs with CPU‑level memory encryption.
            The hypervisor cannot see plaintext. TDX measurement quotes (signed by Intel) prove VM identity and code integrity.
            Use case: Cloud servers, data centers.</li>
        <li><strong>AMD SEV‑SNP (Secure Encrypted Virtualization — Secure Nested Paging):</strong> Similar to TDX, with
            memory controller encryption of VM memory. The VMM cannot decrypt. SEV attestation reports (signed by AMD)
            prove VM integrity. Use case: AMD servers, cloud providers.</li>
        <li><strong>Intel SGX (Software Guard Extensions):</strong> Process‑level enclaves within applications. CPU creates
            encrypted memory regions. SGX attestation quotes (signed by Intel) prove enclave code. Use case:
            Application‑level protection, smaller workloads.</li>
        <li><strong>Apple Secure Enclave (M‑series):</strong> Separate security processor with encrypted memory. Handles
            key generation, encryption, and biometric processing. Attestation via Secure Boot chain and Keychain integrity.
            Use case: Consumer devices (Mac, iPhone, iPad).</li>
    </ul>

    <h4>4.3.3 CVM Isolation and Memory Encryption</h4>
    <div class="box small" id="fig-confidential-compute">
        <div style="text-align:center; font-weight:bold; margin:14px 0 16px 0;">Figure 2. Confidential Compute Isolation (CVM vs. Regular Process)</div>
        <svg viewBox="0 0 850 580" xmlns="http://www.w3.org/2000/svg" style="width:100%; height:auto; font-family:'Times New Roman', serif;">
            <style>
                .blk { fill:#fff; stroke:#000; stroke-width:1; rx:8; ry:8; }
                .cvm-blk { fill:#f0f8ff; stroke:#0066cc; stroke-width:2; rx:8; ry:8; }
                .svg-title { font-size:16px; font-weight:bold; }
                .text { font-size:13px; }
                .arrow { marker-end:url(#arrowhead2); stroke:#000; stroke-width:1; fill:none; }
                .dashed { stroke-dasharray:5,5; }
            </style>
            <defs>
                <marker id="arrowhead2" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                    <polygon points="0 0, 8 3, 0 6" />
                </marker>
            </defs>

            <g transform="translate(0,0)">
            <!-- Left side: Regular Process -->
            <text class="svg-title" x="75" y="30">Regular Process (Unprotected)</text>
            <rect class="blk" x="40" y="50" width="350" height="180"/>
            <text class="text" x="55" y="75">Process Memory</text>
            <text class="text" x="55" y="95">• Plaintext in RAM</text>
            <text class="text" x="55" y="115">• Kernel can read via /dev/mem</text>
            <text class="text" x="55" y="135">• Root can dump keys</text>
            <text class="text" x="55" y="155">• No code integrity proof</text>
            <text class="text" x="55" y="175">• Vulnerable to memory scraping</text>
            <text class="text" x="55" y="195">• No attestation</text>

            <!-- Arrow from kernel to process -->
            <line class="arrow dashed" x1="215" y1="270" x2="215" y2="230"/>
            <text class="text" x="225" y="245" style="font-size:11px;">Kernel/</text>
            <text class="text" x="225" y="258" style="font-size:11px;">Root</text>
            <text class="text" x="225" y="271" style="font-size:11px;">Access</text>

            <!-- Right side: CVM -->
            <text class="svg-title" x="525" y="30">Confidential VM (CVM) (Protected)</text>
            <rect class="cvm-blk" x="460" y="50" width="350" height="180"/>
            <text class="text" x="475" y="75">CVM Memory (Hardware‑Encrypted)</text>
            <text class="text" x="475" y="95">• Encrypted by CPU/MCU</text>
            <text class="text" x="475" y="115">• Hypervisor sees ciphertext</text>
            <text class="text" x="475" y="135">• Root cannot read plaintext</text>
            <text class="text" x="475" y="155">• Measured boot (code hash)</text>
            <text class="text" x="475" y="175">• Remote attestation proof</text>
            <text class="text" x="475" y="195">• Keys sealed to measurement</text>

            <!-- Blocked access indicator -->
            <line class="arrow dashed" x1="635" y1="270" x2="635" y2="230" stroke="#cc0000" stroke-width="2"/>
            <text class="text" x="645" y="245" style="font-size:11px; fill:#cc0000;">Access</text>
            <text class="text" x="645" y="258" style="font-size:11px; fill:#cc0000;">Blocked</text>
            <text class="text" x="645" y="271" style="font-size:11px; fill:#cc0000;">by CPU</text>

            <!-- Bottom: TEE Hardware Layer -->
            <rect class="blk" x="40" y="280" width="770" height="120"/>
            <text class="svg-title" x="425" y="305" style="text-anchor:middle;">Hardware TEE Layer (CPU/MCU)</text>
            <text class="text" x="55" y="330">Intel TDX: CPU encrypts VM memory pages</text>
            <text class="text" x="55" y="350">AMD SEV‑SNP: MCU encrypts VM memory</text>
            <text class="text" x="55" y="370">Intel SGX: CPU encrypts enclave regions</text>
            <text class="text" x="55" y="390">Apple Secure Enclave: Dedicated security processor</text>

            <text class="text" x="500" y="330">Attestation: Hardware signs measurement reports</text>
            <text class="text" x="500" y="350">Verification: Remote verifiers validate reports</text>
            <text class="text" x="500" y="370">Sealing: Keys encrypted under measurement</text>
            <text class="text" x="500" y="390">Isolation: OS/Hypervisor cannot access CVM</text>

            <!-- Attestation flow -->
            <rect class="blk" x="40" y="430" width="770" height="130"/>
            <text class="svg-title" x="425" y="455" style="text-anchor:middle;">Remote Attestation Flow</text>
            
            <rect class="blk" x="60" y="470" width="150" height="70"/>
            <text class="text" x="75" y="492" style="font-weight:bold;">CVM Boot</text>
            <text class="text" x="75" y="512">Generate measurement</text>
            <text class="text" x="75" y="532">(hash of code/data)</text>

            <line class="arrow" x1="210" y1="505" x2="280" y2="505"/>
            <rect class="blk" x="280" y="470" width="150" height="70"/>
            <text class="text" x="295" y="492" style="font-weight:bold;">Attestation</text>
            <text class="text" x="295" y="512">Report</text>
            <text class="text" x="295" y="532">(signed by CPU)</text>

            <line class="arrow" x1="430" y1="505" x2="500" y2="505"/>
            <rect class="blk" x="500" y="470" width="150" height="70"/>
            <text class="text" x="515" y="492" style="font-weight:bold;">Verifier</text>
            <text class="text" x="515" y="512">Validate signature</text>
            <text class="text" x="515" y="532">Check measurement</text>

            <line class="arrow" x1="650" y1="505" x2="720" y2="505"/>
            <rect class="blk" x="720" y="470" width="70" height="70"/>
            <text class="text" x="735" y="492" style="font-weight:bold;">Token</text>
            <text class="text" x="735" y="512">Issued</text>
            </g>
        </svg>
    </div>

    <h4>4.3.4 Why Confidential Compute Matters for Auth‑HF</h4>
    <p>
        The primary threat model addressed by Auth‑HF is a <strong>rogue root administrator</strong> on the same machine.
        Without Confidential Compute, root access allows:
    </p>
    <ul>
        <li>Direct memory reads via <span class="mono">/dev/mem</span> or kernel modules</li>
        <li>Code injection into running processes</li>
        <li>Bypassing filesystem encryption</li>
        <li>Extracting encryption keys from process memory</li>
    </ul>
    <p>
        With Confidential Compute, even root cannot:
    </p>
    <ul>
        <li>Access CVM memory (hardware‑encrypted by CPU/MCU)</li>
        <li>Modify CVM code (measured boot detects tampering; attestation fails)</li>
        <li>Extract keys from memory (keys only decrypt if attestation + HF presence both pass)</li>
        <li>Bypass attestation (keys are sealed to attestation reports; code changes invalidate sealing)</li>
    </ul>
    <p>
        Auth‑HF composes Confidential Compute with HF presence gating to achieve defense in depth:
        keys are released only when <em>both</em> the CVM is attested (code integrity verified)
        <em>and</em> HF presence is active (physiological signals confirm authorized user). This dual
        requirement prevents attacks even when one factor is compromised.
    </p>

    <h3>4.4 JIT Encryption</h3>
    <ul>
        <li>Per‑file keys sealed to CVM attestation (PCRs/TDX report) and policy hash.</li>
        <li>Read: decrypt page in memory if capability valid; write: encrypt on flush; zeroize buffers.</li>
        <li>No plaintext on disk; backing store remains ciphertext to non‑participants.</li>
    </ul>

    <h3>4.5 Attestation‑Gated Key Release</h3>
    <ul>
        <li>Keys released only to a verified CVM instance (remote attestation) and active HF presence.</li>
        <li>Policies: per‑path thresholds, liveness on sensitive ops, environment drift challenges.</li>
    </ul>

    <h3>4.6 Attestation Flow (Diagrammatic)</h3>
    <div class="box small" id="fig-attestation-flow">
        <div style="text-align:center; font-weight:bold; margin:14px 0 16px 0;">Figure 3. Attestation Flow (CVM, Verifier, Key Broker, HF Gateway)</div>
        <svg viewBox="0 0 850 740" xmlns="http://www.w3.org/2000/svg" style="width:100%; height:auto; font-family:'Times New Roman', serif;">
            <style>
                .blk { fill:#fff; stroke:#000; stroke-width:1; rx:8; ry:8; }
                .svg-title { font-size:16px; font-weight:bold; }
                .text { font-size:13px; }
                .arrow { marker-end:url(#arrowhead); stroke:#000; stroke-width:1; fill:none; }
            </style>
            <defs>
                <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                    <polygon points="0 0, 8 3, 0 6" />
                </marker>
            </defs>

            <g transform="translate(0,0)">
            <!-- Vertically aligned blocks with generous spacing -->
            <!-- 1. CVM Evidence -->
            <rect class="blk" x="125" y="40" width="600" height="70"/>
            <text class="svg-title" x="140" y="60">CVM (TDX/SEV‑SNP/SGX)</text>
            <text class="text" x="140" y="80">(1) Boot → Produce attestation evidence (measured report)</text>

            <!-- Arrow to Verifier -->
            <line class="arrow" x1="425" y1="110" x2="425" y2="140"/>

            <!-- 2. Verifier Check -->
            <rect class="blk" x="125" y="140" width="600" height="90"/>
            <text class="svg-title" x="140" y="160">Verifier</text>
            <text class="text" x="140" y="180">(2) Receive {evidence, policy_hash, nonce}</text>
            <text class="text" x="140" y="198">(3) Check measurement, policy, freshness</text>

            <!-- Arrow to Key Broker -->
            <line class="arrow" x1="425" y1="230" x2="425" y2="260"/>

            <!-- 3. Key Broker Authorization -->
            <rect class="blk" x="125" y="260" width="600" height="70"/>
            <text class="svg-title" x="140" y="280">Key Broker</text>
            <text class="text" x="140" y="300">(4) Authorize short‑lived grant for this CVM identity</text>

            <!-- Arrow to HF Gateway -->
            <line class="arrow" x1="425" y1="330" x2="425" y2="360"/>

            <!-- 4. HF Gateway Presence & Capability -->
            <rect class="blk" x="125" y="360" width="600" height="100"/>
            <text class="svg-title" x="140" y="380">HF Gateway</text>
            <text class="text" x="140" y="400">(5) Presence ≥ thresholds (confidence, liveness, ts)</text>
            <text class="text" x="140" y="418">(6) Request per‑op capability {pid, uid, start_time, path, mode}</text>

            <!-- Arrow back to Key Broker (subkey) -->
            <line class="arrow" x1="425" y1="460" x2="425" y2="490"/>

            <!-- 5. Subkey Release to CVM -->
            <rect class="blk" x="125" y="490" width="600" height="70"/>
            <text class="svg-title" x="140" y="510">Key Broker → CVM</text>
            <text class="text" x="140" y="530">(7) Release decryption subkey (TTL ≤ 1s) bound to capability</text>

            <!-- Arrow to CVM JIT IO -->
            <line class="arrow" x1="425" y1="560" x2="425" y2="590"/>

            <!-- 6. JIT I/O in CVM + Audit note -->
            <rect class="blk" x="125" y="590" width="600" height="90"/>
            <text class="svg-title" x="140" y="615">CVM JIT I/O</text>
            <text class="text" x="140" y="637">(8) Verify capability → Decrypt/Encrypt buffer → Zeroize</text>
            <text class="text" x="140" y="655">(9) Signed audit (optional off‑box)</text>
            </g>
        </svg>
    </div>

    <h2>5. Security Analysis</h2>
    <h3>5.1 Resisted Attacks</h3>
    <ul>
        <li><strong>Back‑store reads:</strong> See ciphertext (JIT encryption).</li>
        <li><strong>Bearer theft:</strong> None in design (no HTTP, no bearer tokens).</li>
        <li><strong>PID reuse/ptrace:</strong> pidfd + start_time binding; ptrace restricted via policy; capabilities per‑op.</li>
        <li><strong>TOCTOU:</strong> Verify and I/O in same privileged path.</li>
        <li><strong>Sensor replay:</strong> HF stream uses nonces and prompted liveness.</li>
    </ul>

    <h3>5.2 Residual Risks (and Mitigations)</h3>
    <ul>
        <li><strong>Malicious root on same host:</strong> Mitigated by CVM isolation + attestation; without CVM, memory scraping remains a risk.</li>
        <li><strong>DMA/firmware:</strong> Require IOMMU, secure boot, device lockdown; prefer laptops with modern DMA protection.</li>
        <li><strong>Time subversion:</strong> Use monotonic counters from kernel/TPM; reject backward jumps.</li>
    </ul>

    <h2>6. Deployment Patterns</h2>
    <ul>
        <li>Personal devices: CVM + AF_UNIX gateway + JIT encryption; on‑device only.</li>
        <li>Team devices: Same, with off‑box WORM audit for tamper evidence.</li>
        <li>OEM: Preload CVM image; first‑boot enrollment; measured boot policy.</li>
    </ul>

    <h2>7. Implementation Checklist</h2>
    <ul>
        <li>AF_UNIX gateway with SO_PEERCRED/getpeereid and AEAD capability format.</li>
        <li>HF presence daemon; liveness challenges; secure local prototype store.</li>
        <li>FUSE prototype → LSM/eBPF kernel hook (atomic verify+I/O).</li>
        <li>JIT encryption (AES‑GCM); keys sealed to CVM attestation; key broker API.</li>
        <li>Remote attestation verifier; policy store; audited decisions.</li>
    </ul>

    <h2>8. Implementation Status</h2>
    <p>
        A reference implementation of Auth‑HF has been developed to validate the architecture and demonstrate feasibility.
        The implementation follows the protocol elements outlined in Section 3 and has been tested against the threat model
        in Section 1. What follows is a technical summary of implemented components and their operational status.
    </p>
    
    <h3>8.1 Completed Components</h3>
    <ul>
        <li><strong>HF Presence Detection (Section 3.1):</strong> Implemented with proprietary frequency‑domain analysis for
        Identity Band extraction. Enrollment captures voice and breathing patterns; verification performs
        cosine similarity matching against enrolled prototypes stored in SQLite. Session management uses token‑based
        authentication with expiration. All core operations tested; 16 unit tests passing.</li>
        
        <li><strong>Attestation Verifier and Key Broker (Section 3.4):</strong> macOS implementation uses Secure Boot chain
        measurements, Keychain integrity, code signing, and system measurements as attestation evidence. Verifier validates
        attestation reports, checks policy hashes, and prevents replay via nonce verification. Key Broker gates key release
        on valid attestation tokens and enrolled owner signatures. Framework for Intel TDX, AMD SEV‑SNP, and Intel SGX
        available for hardware TEE support. 27 unit tests passing.</li>
        
        <li><strong>JIT Encryption (Section 3.3):</strong> Encrypted container implementation uses AES‑GCM with per‑file keys.
        Master key stored in macOS Secure Enclave via Keychain Services with hardware protection. Files encrypted on disk;
        decryption occurs in memory during verified I/O operations. Buffer zeroization on close. Container API provides
        <span class="mono">StoreFile()</span> and <span class="mono">RetrieveFile()</span> operations with capability
        validation gates.</li>
        
        <li><strong>HF Gateway:</strong> Integrates presence service with key broker. Verifies HF presence using thresholds
        (min similarity 0.60, min confidence 0.30) before issuing capabilities. Liveness detection implemented. Gateway
        orchestrates presence check → attestation validation → capability issuance flow.</li>
        
        <li><strong>CLI Tool and Menu Bar Widget:</strong> Command‑line interface provides <span class="mono">hf setup</span>
        (interactive enrollment), <span class="mono">hf run</span> (daemon start), and <span class="mono">hf status</span>
        (status check). macOS menu bar widget displays HF icon with status colors (green: protected, yellow: warning, red:
        error) and provides status API on <span class="mono">localhost:43529</span>.</li>
    </ul>
    
    <h3>8.2 Operational Validation</h3>
    <p>
        The implementation has been tested with real‑world files and scenarios:
    </p>
    <ul>
        <li>Encrypted container successfully protects files against rogue administrator access attempts; master key remains
        in Secure Enclave and is not accessible via filesystem or memory inspection.</li>
        <li>HF presence enrollment and verification operate correctly; owner signatures persist across service restarts via
        database storage.</li>
        <li>macOS attestation generates valid reports that pass verification; key broker releases keys only after
        successful attestation validation.</li>
        <li>Menu bar widget correctly displays status based on daemon state and vault mount status.</li>
    </ul>
    
    <h3>8.3 Limitations and Future Work</h3>
    <p>
        The current implementation demonstrates core security properties but has architectural limitations that require
        additional development for production deployment:
    </p>
    <ul>
        <li><strong>Filesystem Integration:</strong> File protection is currently API‑based (<span class="mono">container.StoreFile()</span>).
        FUSE integration (Section 3.5) is not implemented; transparent filesystem access requires manual API calls.</li>
        
        <li><strong>Kernel Enforcement:</strong> Atomic verify+I/O operations (Section 3.2) are implemented at the API
        layer, not at kernel/filesystem boundaries. TOCTOU protection requires FUSE or LSM/eBPF hooks for full enforcement.</li>
        
        <li><strong>Continuous Presence:</strong> HF presence is verified on‑demand during capability requests, not
        continuously. Implementation supports periodic presence checks but lacks real‑time audio streaming for continuous
        monitoring.</li>
        
        <li><strong>Per‑Operation Capabilities:</strong> Capability framework exists (Section 3.2) but Unix Domain Socket
        peer credential extraction on macOS requires additional CGO work for production‑grade <span class="mono">SO_PEERCRED</span>
        support. Current implementation uses process identity fallbacks.</li>
        
        <li><strong>Hardware TEE Integration:</strong> Intel TDX, AMD SEV‑SNP, and Intel SGX frameworks are implemented as
        mocks for testing. Production deployment requires hardware TEE integration and remote attestation service
        connectivity (e.g., Intel IAS for SGX/TDX).</li>
    </ul>
    
    <div class="box small">
        <p><strong>Status Summary.</strong> Core security model (HF presence, attestation, JIT encryption, Secure Enclave)
        is implemented and validated. Filesystem integration, kernel enforcement, and continuous presence monitoring are
        architectural extensions planned for future releases. The implementation demonstrates feasibility of the Auth‑HF
        protocol and provides a foundation for production deployment once filesystem integration is complete.</p>
    </div>

    <h2>9. Conclusion</h2>
    <p>
        For personal AI to be trustworthy on user devices, authorization must be continuous, identity‑bound, and
        hardware‑attested. Auth‑HF unifies HF presence, per‑operation capabilities, JIT encryption, and confidential VMs
        to resist even rogue, rooted administrators on the same host. This elevates local protection from best‑effort to
        attested security—fit for bio‑data and AI models.
    </p>
    <p>
        The reference implementation validates core protocol elements and demonstrates operational security against the
        threat model. Remaining work focuses on filesystem integration and kernel enforcement to achieve transparent,
        production‑grade deployment.
    </p>

    <h2>10. Prior Art and Comparative Analysis (Accessed Oct 30, 2025)</h2>
    <h3>10.1 Disk Encryption and Integrity</h3>
    <ul>
        <li><strong>dm‑crypt/LUKS, FileVault, BitLocker:</strong> Strong at‑rest protection, but once mounted, any privileged process can read plaintext. Auth‑HF differs by binding <em>each I/O</em> to HF presence and attested execution, with JIT encryption preventing direct backing‑store reads.</li>
        <li><strong>fs‑verity:</strong> Merkle integrity for read‑only files; does not provide per‑op authorization or presence gating. Auth‑HF complements integrity with presence‑gated decryption.</li>
    </ul>

    <h3>10.2 OS Policy and Mandatory Access Control</h3>
    <ul>
        <li><strong>SELinux/AppArmor/MAC:</strong> Kernel‑enforced labeling and policies; powerful but ultimately configurable by root. Auth‑HF raises the bar by sealing decryption keys to attestation and HF presence, preventing root-only policy edits from exposing plaintext.</li>
        <li><strong>FreeBSD Capsicum / Capability mode:</strong> Process‑scoped capabilities restrict ambient authority; Auth‑HF adopts a per‑operation, AEAD‑sealed capability approach bound to pid/uid/start_time/path/mode and TTL ≤1s, integrating presence and attestation in the issuance path.</li>
        <li><strong>LSM/eBPF Hooks:</strong> Provide enforcement points; Auth‑HF uses them (or a FUSE prototype) to ensure verify+I/O atomicity.</li>
    </ul>

    <h3>10.3 Confidential Computing and Attestation</h3>
    <ul>
        <li><strong>Intel SGX, Intel TDX, AMD SEV‑SNP:</strong> Enclaves/VMs with measurement and remote attestation. Prior works seal keys to PCR/TDX/SEV identities for cloud multi‑tenant isolation. Auth‑HF applies attestation locally: keys are released to a measured CVM on the <em>same device</em> only under active HF presence; file service and key broker reside inside the CVM to resist same‑host root.</li>
        <li><strong>Measured Boot/TPM Key Sealing:</strong> Standard practice for sealing keys to boot state; Auth‑HF additionally seals to presence and per‑op capabilities, reducing reuse risks.</li>
    </ul>

    <h3>10.4 Filesystem Interposition</h3>
    <ul>
        <li><strong>Windows Minifilter, macFUSE/FUSE:</strong> Intercept VFS operations; widely used for AV/DLP/overlay FS. Prior art typically relies on user identity or static policy. Auth‑HF issues process‑bound, per‑operation capabilities over AF_UNIX (SO_PEERCRED/getpeereid) and performs JIT decryption only when capability + presence + attestation all pass.</li>
    </ul>

    <h3>10.5 Local IPC Credentials</h3>
    <ul>
        <li><strong>AF_UNIX with SO_PEERCRED/SCM_CREDENTIALS, getpeereid:</strong> Known technique to authenticate peer pid/uid without bearer tokens. Auth‑HF builds on this by adding AEAD‑sealed per‑op capabilities with nonces and monotonic counters, verified in the same privileged path that executes I/O.</li>
    </ul>

    <h3>10.6 Biometric/Presence Systems</h3>
    <ul>
        <li><strong>FIDO/WebAuthn, OS biometrics:</strong> Strong user presence for login/unlock events. Auth‑HF differs by <em>continuous</em> presence (HF) and liveness driving <em>every</em> I/O capability, not just a session start, and by combining this with CVM‑gated key release.</li>
    </ul>

    <div class="box small">
        <p><strong>Summary.</strong> Prior art secures at rest (dm‑crypt), enforces kernel policy (MAC), or attests compute (SGX/TDX/SEV‑SNP). Auth‑HF's contribution is to <em>compose</em> these: continuous HF presence → per‑op, process‑bound capability → JIT decryption → CVM attestation‑gated key release, achieving resistance even against same‑host root while the system is up.</p>
    </div>

    <h2>11. Coercion‑Resistance and Free‑Will Aligned Authorization</h2>
    <p>
        A distinctive property of HF presence is that it is <em>physiology‑grounded</em>. Beyond identity and liveness,
        the signal carries markers of stress, fear, and abnormal arousal (e.g., respiration variability, prosody,
        alpha/beta band shifts). Auth‑HF can incorporate a <strong>duress policy</strong>: when specific stress patterns
        and context conditions co‑occur, decryption keys are not released, or a decoy profile is served, or a delay and
        out‑of‑band verification are triggered. This design aims to protect users even when they are physically present
        but acting under coercion.
    </p>
    <div class="box small">
        <p><strong>Mechanism (optional, policy‑gated).</strong></p>
        <ul>
            <li>Continuous HF features: breath cadence, micro‑tremor, prosodic tension, EEG alpha/beta ratios.</li>
            <li>Classifier calibrated per user during enrollment (opt‑in) to detect duress signatures.</li>
            <li>Policy actions: deny key release; switch to decoy dataset; require remote contact; randomize wait windows.</li>
            <li>Attestation tie‑in: duress flag prevents key release even to an attested CVM.</li>
        </ul>
    </div>
    <p>
        <strong>Scope and limits.</strong> Coercion resistance from biosignals is probabilistic. It can reduce success of
        overt, time‑pressured coercion, and it can deter attacks if publicized. However, adversaries may attempt to
        game signals (forced breathing exercises, scripted calm, pharmacological dampening). The system must therefore:
        (1) remain <em>opt‑in</em> with user‑set thresholds, (2) favor <em>fail‑safe</em> denial on high‑risk assets, and
        (3) provide emergency escape channels defined by the user (e.g., safe‑phrase to alert and lock).
    </p>
    <p>
        We consider this alignment with free will—refusing to unlock under duress—an authentic strength of HF‑based
        authorization when deployed with careful calibration and transparent user control. It is not a guarantee against
        all coercion; rather, it is an added protective layer that traditional password/biometric systems cannot offer,
        because they lack continuous physiological context.
    </p>

    <h2>12. References</h2>
    <div class="references">
        <ol>
            <li>
                <p>Linux Unified Key Setup (LUKS). Linux kernel documentation. kernel.org. Accessed October 30, 2025. 
                <span class="mono">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/admin-guide/device-mapper/dm-crypt.rst</span></p>
            </li>
            <li>
                <p>fs‑verity: Filesystem‑level integrity verification. Linux kernel documentation. kernel.org. Accessed October 30, 2025. 
                <span class="mono">https://www.kernel.org/doc/html/latest/filesystems/fsverity.html</span></p>
            </li>
            <li>
                <p>SELinux Project. Security‑Enhanced Linux. selinuxproject.org. Accessed October 30, 2025. 
                <span class="mono">https://selinuxproject.org</span></p>
            </li>
            <li>
                <p>AppArmor. Mandatory Access Control (MAC) for Linux. apparmor.net. Accessed October 30, 2025. 
                <span class="mono">https://apparmor.net</span></p>
            </li>
            <li>
                <p>Watson, R. N., Anderson, J., Laurie, B., & Kennaway, K. (2010). Capsicum: Practical Capabilities for UNIX. 
                In <em>Proceedings of the 19th USENIX Security Symposium</em>. FreeBSD Project.</p>
            </li>
            <li>
                <p>Intel Corporation. Intel Software Guard Extensions (Intel SGX) Architecture. 
                Intel Architecture Specification. Accessed October 30, 2025. 
                <span class="mono">https://www.intel.com/content/www/us/en/developer/tools/software-guard-extensions/overview.html</span></p>
            </li>
            <li>
                <p>Intel Corporation. Intel Trust Domain Extensions (Intel TDX) Architecture. 
                Intel Architecture Specification. Accessed October 30, 2025. 
                <span class="mono">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html</span></p>
            </li>
            <li>
                <p>AMD Corporation. AMD Secure Encrypted Virtualization (SEV‑SNP): Strengthening VM Isolation. 
                AMD Technical Whitepaper. Accessed October 30, 2025. 
                <span class="mono">https://www.amd.com/en/developer/sev.html</span></p>
            </li>
            <li>
                <p>Unix Domain Sockets with SO_PEERCRED. Linux Programmer's Manual. man7.org. Accessed October 30, 2025. 
                <span class="mono">https://man7.org/linux/man-pages/man7/unix.7.html</span></p>
            </li>
            <li>
                <p>SCM_CREDENTIALS, getpeereid. POSIX.1 and Unix specification. Apple Developer Documentation. 
                Accessed October 30, 2025. 
                <span class="mono">https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getpeereid.2.html</span></p>
            </li>
            <li>
                <p>Microsoft Corporation. Windows Minifilter Driver Model. Microsoft Docs. Accessed October 30, 2025. 
                <span class="mono">https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts</span></p>
            </li>
            <li>
                <p>macFUSE Project. FUSE for macOS. macfuse.github.io. Accessed October 30, 2025. 
                <span class="mono">https://macfuse.github.io</span></p>
            </li>
            <li>
                <p>FIDO Alliance. FIDO2/WebAuthn Specifications. fidoalliance.org. Accessed October 30, 2025. 
                <span class="mono">https://fidoalliance.org/specifications</span></p>
            </li>
            <li>
                <p>W3C Web Authentication Working Group. Web Authentication: An API for accessing Public Key Credentials Level 2. 
                W3C Recommendation. Accessed October 30, 2025. 
                <span class="mono">https://www.w3.org/TR/webauthn-2</span></p>
            </li>
            <li>
                <p>Krawczyk, H., & Bellare, M. (1997). HMAC: Keyed‑Hashing for Message Authentication. 
                RFC 2104. IETF. <span class="mono">https://tools.ietf.org/html/rfc2104</span></p>
            </li>
            <li>
                <p>McGrew, D., & Viega, J. (2005). The Galois/Counter Mode of Operation (GCM). 
                NIST Special Publication 800-38D. National Institute of Standards and Technology.</p>
            </li>
        </ol>
    </div>
    <h2>Appendix A: Capability Format and Verification</h2>
    <p>
        Per‑operation capabilities are issued by the HF Gateway after presence verification and sealed with
        AEAD encryption using the CVM's key (<span class="mono">K_cvm</span>). The capability structure binds
        process identity, file path, operation mode, and expiration to prevent replay and PID reuse attacks.
    </p>
    
    <h3>A.1 Capability Structure</h3>
    <div class="box small">
        <p><strong>Sealed capability format:</strong></p>
        <pre class="mono">cap = AEAD_Seal({
  pid: process_id,
  uid: user_id,
  start_time: process_start_timestamp,
  cgroup: control_group_id,
  inode: file_inode,
  path: "/protected/data/file.txt",
  mode: "read" | "write" | "list" | "delete",
  counter: monotonic_counter,
  exp: now + 750ms
}, key=K_cvm, nonce=random_nonce)</pre>
    </div>
    
    <h3>A.2 Verification Steps</h3>
    <p>
        Before I/O operations, the CVM verifies the capability:
    </p>
    <ol>
        <li><strong>Unseal:</strong> <span class="mono">data = AEAD_Unseal(cap, key=K_cvm)</span> to decrypt and authenticate.</li>
        <li><strong>Expiration:</strong> Check <span class="mono">exp &gt; now</span> (TTL ≤ 1s enforced).</li>
        <li><strong>Process binding:</strong> Verify <span class="mono">pid</span>, <span class="mono">uid</span>, and <span class="mono">start_time</span> match peer credentials from AF_UNIX socket (<span class="mono">SO_PEERCRED</span>).</li>
        <li><strong>Path and mode:</strong> Validate <span class="mono">path</span> and <span class="mono">mode</span> match the requested operation.</li>
        <li><strong>Replay protection:</strong> Check <span class="mono">counter</span> against monotonic store; increment on use.</li>
    </ol>
    
    <p>
        If all checks pass, the CVM proceeds with JIT decryption and I/O. The capability is single‑use
        (counter increment) or short‑lived (expiration), preventing reuse even if intercepted.
    </p>

    <hr style="border: none; border-top: 1px solid #000; margin: 0.4in 0 0.2in 0;">
    <p style="text-align: center; font-size: 11pt; font-style: italic;">
        Document Version: 1.3<br>
        Published: February 2026<br>
        Status: Public Release<br>
        All rights reserved. Univault Technologies, Inc.<br>
        &copy; 2026 ParagonDAO / Univault Technologies. research@paragondao.org &mdash; paragondao.org
    </p>

    <!-- Sentinel Frog -->
    <div class="sentinel-frog" title="Breathe with me — click to connect your health" onclick="this.style.bottom='38px';setTimeout(()=>this.style.bottom='20px',400);setTimeout(()=>window.location.href='/',600)">
        <svg width="56" height="52" viewBox="0 0 56 52" fill="none" xmlns="http://www.w3.org/2000/svg">
            <ellipse class="frog-glow" cx="28" cy="36" rx="24" ry="16" fill="rgba(45,212,191,0.08)"/>
            <ellipse class="frog-body" cx="28" cy="35" rx="19" ry="14" fill="#14b8a6"/>
            <ellipse class="frog-belly" cx="28" cy="36" rx="13" ry="9" fill="#ccfbf1" opacity="0.45"/>
            <ellipse cx="12" cy="42" rx="6" ry="4" fill="#0f766e" opacity="0.7" transform="rotate(-15,12,42)"/>
            <ellipse cx="44" cy="42" rx="6" ry="4" fill="#0f766e" opacity="0.7" transform="rotate(15,44,42)"/>
            <g opacity="0.8"><circle cx="7" cy="45" r="2" fill="#0f766e"/><circle cx="10" cy="46" r="1.8" fill="#0f766e"/><circle cx="4" cy="46" r="1.5" fill="#0f766e"/><circle cx="49" cy="45" r="2" fill="#0f766e"/><circle cx="46" cy="46" r="1.8" fill="#0f766e"/><circle cx="52" cy="46" r="1.5" fill="#0f766e"/></g>
            <rect x="16" y="40" width="4" height="8" rx="2" fill="#0f766e" opacity="0.6" transform="rotate(-5,18,44)"/>
            <rect x="36" y="40" width="4" height="8" rx="2" fill="#0f766e" opacity="0.6" transform="rotate(5,38,44)"/>
            <g opacity="0.7"><circle cx="15" cy="48" r="1.5" fill="#0f766e"/><circle cx="18" cy="49" r="1.3" fill="#0f766e"/><circle cx="38" cy="49" r="1.3" fill="#0f766e"/><circle cx="41" cy="48" r="1.5" fill="#0f766e"/></g>
            <g class="frog-head">
                <ellipse cx="28" cy="23" rx="15" ry="12" fill="#14b8a6"/>
                <ellipse class="frog-throat" cx="28" cy="28" rx="5" ry="3.5" fill="#ccfbf1" opacity="0.3"/>
                <circle cx="17" cy="26" r="4" fill="rgba(251,191,36,0.25)"/>
                <circle cx="39" cy="26" r="4" fill="rgba(251,191,36,0.25)"/>
                <circle cx="20" cy="14" r="8.5" fill="#14b8a6"/>
                <circle cx="36" cy="14" r="8.5" fill="#14b8a6"/>
                <g class="frog-eyes">
                    <circle cx="20" cy="14" r="6.5" fill="#fff"/>
                    <circle cx="36" cy="14" r="6.5" fill="#fff"/>
                    <circle cx="20" cy="14" r="3.8" fill="#f0bb33"/>
                    <circle cx="36" cy="14" r="3.8" fill="#f0bb33"/>
                    <circle cx="20" cy="14" r="2.2" fill="#5c3d0e"/>
                    <circle cx="36" cy="14" r="2.2" fill="#5c3d0e"/>
                    <circle cx="19" cy="12" r="1.3" fill="#fff" opacity="0.9"/>
                    <circle cx="35" cy="12" r="1.3" fill="#fff" opacity="0.9"/>
                </g>
                <g class="frog-nostrils">
                    <ellipse cx="25" cy="23" rx="1.2" ry="0.9" fill="#0f766e" opacity="0.3"/>
                    <ellipse cx="31" cy="23" rx="1.2" ry="0.9" fill="#0f766e" opacity="0.3"/>
                </g>
                <path d="M22 27 Q28 31 34 27" fill="none" stroke="#0f766e" stroke-width="1.2" stroke-linecap="round"/>
                <g opacity="0.7"><circle cx="28" cy="6" r="2.2" fill="#f0bb33"/><circle cx="23" cy="8" r="1.6" fill="#d4a017"/><circle cx="33" cy="8" r="1.6" fill="#d4a017"/></g>
            </g>
        </svg>
    </div>

</body>
</html>
